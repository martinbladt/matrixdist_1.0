# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Default size of the steps in the RK
default_step_length <- function(T) {
    .Call(`_matrixdist_default_step_length`, T)
}

#' Runge Kutta for the calculation of the a,b and c vectors in a EM step
#' 
#' I may need to change the type of avector and bvector, depending on how I call them in the EM step
runge_kutta <- function(avector, bvector, cmatrix, dt, h, T, t) {
    invisible(.Call(`_matrixdist_runge_kutta`, avector, bvector, cmatrix, dt, h, T, t))
}

#' EM step using Runge Kutta
#' 
#' Computes one step of the EM algorithm by using a Runge-Kutta method of 4th order
EMstep_RK <- function(h, pi, T, obs, weight, rcens, rcweight) {
    invisible(.Call(`_matrixdist_EMstep_RK`, h, pi, T, obs, weight, rcens, rcweight))
}

#' Runge Kutta for the calculation of the a vectors in a EM step - Can be used for the loglikelihood
#' 
#' I may need to change the type of avector
a_rungekutta <- function(avector, dt, h, T) {
    invisible(.Call(`_matrixdist_a_rungekutta`, avector, dt, h, T))
}

#' Loglikelihood using RK
logLikelihoodPH_RK <- function(h, pi, T, obs, weight, rcens, rcweight) {
    .Call(`_matrixdist_logLikelihoodPH_RK`, h, pi, T, obs, weight, rcens, rcweight)
}

#' Loglikelihood IPH using RK and g as an input
#' One needs to be careful with the GEV since it is decreasing
#' It is slower than using the density directly - Perhaps is the iteration with R 
logLikelihoodIPH_RK <- function(h, pi, T, g, g_inv, lambda, beta, obs, weight, rcens, rcweight) {
    .Call(`_matrixdist_logLikelihoodIPH_RK`, h, pi, T, g, g_inv, lambda, beta, obs, weight, rcens, rcweight)
}

#' Loglikelihood of matrix Weibull using RK
#' This is the fastest option
logLikelihoodMWeib_RK <- function(h, pi, T, beta, obs, weight, rcens, rcweight) {
    .Call(`_matrixdist_logLikelihoodMWeib_RK`, h, pi, T, beta, obs, weight, rcens, rcweight)
}

#' Loglikelihood of matrix Pareto using RK
logLikelihoodMPar_RK <- function(h, pi, T, beta, obs, weight, rcens, rcweight) {
    .Call(`_matrixdist_logLikelihoodMPar_RK`, h, pi, T, beta, obs, weight, rcens, rcweight)
}

#' Loglikelihood of matrix Gompertz using RK
logLikelihoodMGomp_RK <- function(h, pi, T, beta, obs, weight, rcens, rcweight) {
    .Call(`_matrixdist_logLikelihoodMGomp_RK`, h, pi, T, beta, obs, weight, rcens, rcweight)
}

#' Loglikelihood of matrix GEV using RK
#' I am assuming that the sample is given in an increasing order
logLikelihoodMGEV_RK <- function(h, pi, T, beta, obs, weight, rcens, rcweight) {
    .Call(`_matrixdist_logLikelihoodMGEV_RK`, h, pi, T, beta, obs, weight, rcens, rcweight)
}

#' Applies the inverse of the GEV but giving back the vector in reverse order
reversTransformData <- function(observations, weights, beta) {
    .Call(`_matrixdist_reversTransformData`, observations, weights, beta)
}

#'  EM for a Bivariate PH fit
#'  
EMstep_bivph <- function(observations, weights, alpha, T11, T12, T22) {
    invisible(.Call(`_matrixdist_EMstep_bivph`, observations, weights, alpha, T11, T12, T22))
}

#' Embeded Markov chain of a sub-intensity matrix
#' 
#' Returns the transition probabilities of the embeded Markov chain determined the sub-intensity matrix 
#' @param T A sub-intensity matrix
#' @return The embeded Markov chain
#' @examples
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' embeddedMC(T)
embeddedMC <- function(T) {
    .Call(`_matrixdist_embeddedMC`, T)
}

#' Cumulate matrix
#' 
#' Creates a new matrix with entries the cumulated rows of \code{A}
#' @param A A matrix
#' @return The cumulated matrix
cumulateMatrix <- function(A) {
    .Call(`_matrixdist_cumulateMatrix`, A)
}

#' Cumulate vector
#' 
#' Creates a new vector with entries the cumulated entries of \code{A}
#' @param A A vector
#' @return The cumulated vector
cumulateVector <- function(A) {
    .Call(`_matrixdist_cumulateVector`, A)
}

#' Initial state of Markov jump process
#' 
#' Given the accumulated values of the initial probabilities \code{Pi} and a uniform value \code{u}, it returns the initial state of a Markov jump process
#' @param cumulatedPi A vector
#' @param u A random value in (0,1)
#' @return The initial state of the Markov jump process
initialState <- function(cumulatedPi, u) {
    .Call(`_matrixdist_initialState`, cumulatedPi, u)
}

#' New state in a Markov jump process
#' 
#' Given a transition matrix \code{Q}, a uniform value \code{u}, and a previous state \code{k}, it returns the new state of a Markov jump process
#' @param previousState Previous state of the Markov jump process
#' @param cumulatedEmbeddedMC A transition matrix
#' @param u A random value in (0,1)
#' @return The next state of the Markov jump process
newState <- function(previousState, cumulatedEmbeddedMC, u) {
    .Call(`_matrixdist_newState`, previousState, cumulatedEmbeddedMC, u)
}

#' Random phase-type
#' 
#' Generates a sample of size \code{n} from a phase-type distribution with parameters \code{pi} and \code{T}
#' @parm n Sample size
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @return The simulated sample
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' n <- 10
#' rphasetype(n, alpha, T) 
rphasetype <- function(n, pi, T) {
    .Call(`_matrixdist_rphasetype`, n, pi, T)
}

#' Random inhomogeneous phase-type
#' 
#' Generates a sample of size \code{n} from an inhomogeneous phase-type distribution with parameters \code{pi}, \code{T} and \code{beta}
#' @parm n Sample size
#' @parm dist_type Type of IPH: "Pareto", "Weibull", "Gompertz"
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta Parameter of the transformation
#' @return The simulated sample
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' beta <- 0.5
#' n <- 10
#' riph(n, "Pareto", alpha, T, beta) 
riph <- function(n, dist_type, pi, T, beta) {
    .Call(`_matrixdist_riph`, n, dist_type, pi, T, beta)
}

#' Random matrix GEVD
#' 
#' Generates a sample of size \code{n} from an inhomogeneous phase-type distribution with parameters \code{pi}, \code{T} and \code{beta}
#' @parm n Sample size
#' @parm dist_type Type of IPH: "Pareto", "Weibull", "Gompertz"
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param mu Location parameter
#' @param sigma Scale parameter
#' @param xi Shape parameter: Default 0 which corresponds to the Gumbel case
#' @return The simulated sample
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' mu <- 3
#' sigma <- 2
#' xi <- 0.5
#' n <- 10
#' rmatrixGEVD(n, alpha, T, mu, sigma, xi) 
#' rmatrixGEVD(n, alpha, T, mu, sigma) 
rmatrixGEVD <- function(n, pi, T, mu, sigma, xi = 0) {
    .Call(`_matrixdist_rmatrixGEVD`, n, pi, T, mu, sigma, xi)
}

#' Random inhomogeneous phase-type
#' 
#' Generates a sample of size \code{n} from an inhomogeneous phase-type distribution with parameters \code{pi}, \code{T} and \code{beta}
#' @parm n Sample size
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta Parameter of the transformation
#' @return The simulated sample
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' g <- function(x, beta) { x^(1/beta) }
#' beta <- 0.5
#' n <- 10
#' riphfn(n, alpha, T, g, beta) 
riphfn <- function(n, pi, T, g, beta) {
    .Call(`_matrixdist_riphfn`, n, pi, T, g, beta)
}

#' Random MPH*
#' 
#' Generates a sample of size \code{n} from a MPH* distribution with parameters \code{pi}, \code{T} and \code{R}
#' @parm n Sample size
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @return The simulated sample
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' R <- matrix(c(c(1,0,0.8),c(0,1,0.2)), nrow = 3, ncol = 2)
#' n <- 10
#' rmph(n, alpha, T, R) 
rmph <- function(n, pi, T, R) {
    .Call(`_matrixdist_rmph`, n, pi, T, R)
}

#' Random Inhomogeneous MPH*
#' 
#' Generates a sample of size \code{n} from an Inhomogeneous MPH* distribution with parameters \code{pi}, \code{T} and \code{R}
#' @param n Sample size
#' @param dist_type Type of distribution: "Weibull" "Pareto"
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta parameters of the transformations
#' @return The simulated sample
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' R <- matrix(c(c(1,0,0.8),c(0,1,0.2)), nrow = 3, ncol = 2)
#' beta <- c(0.4, 0.7)
#' n <- 10
#' rimph(n, "Weibull", alpha, T, R, beta) 
rimph <- function(n, dist_type, pi, T, R, beta) {
    .Call(`_matrixdist_rimph`, n, dist_type, pi, T, R, beta)
}

#' Phase-type density
#' 
#' Computes the density of phase-type distribution with parameters \code{pi} and \code{T} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @return The density at \code{x}
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' phdensity(0.5, alpha, T) 
phdensity <- function(x, pi, T) {
    .Call(`_matrixdist_phdensity`, x, pi, T)
}

#' Phase-type cdf or tail
#' 
#' Computes the cdf of phase-type distribution with parameters \code{pi} and \code{T} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @return The cdf (tail) at \code{x}
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' phcdf(0.5, alpha, T) 
#' phcdf(0.5, alpha, T, FALSE) 
phcdf <- function(x, pi, T, lower_tail = TRUE) {
    .Call(`_matrixdist_phcdf`, x, pi, T, lower_tail)
}

#' k moment of a phase-type
#' 
#' Computes the k moment of phase-type distribution with parameters \code{pi} and \code{T}
#' @param k Integer value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @return The k moment
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' phmoment(2, alpha, T) 
#' phmoment(4, alpha, T) 
phmoment <- function(k, pi, T) {
    .Call(`_matrixdist_phmoment`, k, pi, T)
}

#' Laplace transform of a phase-type
#' 
#' Computes the Laplace transform at \code{s} of a phase-type distribution with parameters \code{pi} and \code{T}
#' @param s real value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @return Laplace transform
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' phLaplace(0.5, alpha, T) 
#' phLaplace(2.5, alpha, T) 
phLaplace <- function(s, pi, T) {
    .Call(`_matrixdist_phLaplace`, s, pi, T)
}

#' IPH density - Slower
#' 
#' Computes the density of an IPH distribution with parameters \code{pi}, \code{T} and \code{beta} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param g Tranformation 
#' @param g_inv Inverse of the transformation
#' @param lambda Derivative of the inverse
#' @param beta parameter of the transformation
#' @return The density at \code{x}
#' @examples
#' g <- function(x, beta) { x^(1/beta) }
#' g_inv <- function(x, beta) { x^beta}
#' lambda <- function(x, beta) {beta * x^(beta - 1)}
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' beta <- 0.5
#' iphdensity(0.5, alpha, T, g, g_inv, lambda, beta) 
iphdensity <- function(x, pi, T, g, g_inv, lambda, beta) {
    .Call(`_matrixdist_iphdensity`, x, pi, T, g, g_inv, lambda, beta)
}

#' IPH cdf (tail)
#' 
#' Computes the cdf(tail) of an IPH distribution with parameters \code{pi}, \code{T} and \code{beta} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param g Tranformation 
#' @param g_inv Inverse of the transformation
#' @param lambda Derivative of the inverse
#' @param beta parameter of the transformation
#' @return The cdf (tail) at \code{x}
#' @examples
#' g <- function(x, beta) { x^(1/beta) }
#' g_inv <- function(x, beta) { x^beta}
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' beta <- 0.5
#' iphcdf(0.5, alpha, T, g, g_inv, beta)
#' iphcdf(0.5, alpha, T, g, g_inv, beta, FALSE) 
iphcdf <- function(x, pi, T, g, g_inv, beta, lower_tail = TRUE) {
    .Call(`_matrixdist_iphcdf`, x, pi, T, g, g_inv, beta, lower_tail)
}

#' Matrix Weibull density
#' 
#' Computes the density of a matrix Weibull distribution with parameters \code{pi}, \code{T} and \code{beta} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta shape parameter
#' @return The density at \code{x}
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' beta <- 0.5
#' mweibullden(0.5, alpha, T, beta) 
mWeibullden <- function(x, pi, T, beta) {
    .Call(`_matrixdist_mWeibullden`, x, pi, T, beta)
}

#' Matrix Weibull cdf
#' 
#' Computes the cdf (tail) of a matrix Weibull distribution with parameters \code{pi}, \code{T} and \code{beta} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta shape parameter
#' @return The cdf (tail) at \code{x}
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' beta <- 0.5
#' mweibullcdf(0.5, alpha, T, beta) 
#' mweibullcdf(0.5, alpha, T, beta, FALSE) 
mWeibullcdf <- function(x, pi, T, beta, lower_tail = TRUE) {
    .Call(`_matrixdist_mWeibullcdf`, x, pi, T, beta, lower_tail)
}

RunFunction <- function(a, func) {
    .Call(`_matrixdist_RunFunction`, a, func)
}

#' Matrix Pareto density
#' 
#' Computes the density of a matrix Pareto distribution with parameters \code{pi}, \code{T} and \code{beta} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta scale parameter
#' @return The density at \code{x}
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' beta <- 0.5
#' mparetoden(0.5, alpha, T, beta) 
mParetoden <- function(x, pi, T, beta) {
    .Call(`_matrixdist_mParetoden`, x, pi, T, beta)
}

#' Matrix Pareto cdf
#' 
#' Computes the cdf (tail) of a matrix Pareto distribution with parameters \code{pi}, \code{T} and \code{beta} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta shape parameter
#' @return The cdf (tail) at \code{x}
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' beta <- 0.5
#' mparetocdf(0.5, alpha, T, beta) 
#' mparetocdf(0.5, alpha, T, beta, FALSE) 
mParetocdf <- function(x, pi, T, beta, lower_tail = TRUE) {
    .Call(`_matrixdist_mParetocdf`, x, pi, T, beta, lower_tail)
}

#' Matrix Gompertz density
#' 
#' Computes the density of a matrix Gompertz distribution with parameters \code{pi}, \code{T} and \code{beta} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta  parameter
#' @return The density at \code{x}
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' beta <- 0.5
#' mgompertzden(0.5, alpha, T, beta) 
mGompertzden <- function(x, pi, T, beta) {
    .Call(`_matrixdist_mGompertzden`, x, pi, T, beta)
}

#' Matrix Gompertz cdf
#' 
#' Computes the cdf (tail) of a matrix Gompertz distribution with parameters \code{pi}, \code{T} and \code{beta} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta shape parameter
#' @return The cdf (tail) at \code{x}
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' beta <- 0.5
#' mgompertzcdf(0.5, alpha, T, beta) 
#' mgompertzcdf(0.5, alpha, T, beta, FALSE) 
mGompertzcdf <- function(x, pi, T, beta, lower_tail = TRUE) {
    .Call(`_matrixdist_mGompertzcdf`, x, pi, T, beta, lower_tail)
}

#' Matrix GEV density
#' 
#' Computes the density of a matrix GEV distribution with parameters \code{pi}, \code{T} and \code{beta} at \code{x}
#' Dont allow for atoms in zero
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta  parameter
#' @return The density at \code{x}
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' mu <- 1
#' sigma <- 2
#' xi <- 0.5
#' mGEVden(0.5, alpha, T, mu, sigma, xi) 
mGEVDden <- function(x, pi, T, mu, sigma, xi) {
    .Call(`_matrixdist_mGEVDden`, x, pi, T, mu, sigma, xi)
}

#' Matrix GEV cdf
#' 
#' Computes the cdf (tail) of a matrix GEV distribution with parameters \code{pi}, \code{T} and \code{beta} at \code{x}
#' @param x non-negative value
#' @param pi Initial probabilities
#' @param T sub-intensity matrix
#' @param beta shape parameter
#' @return The cdf (tail) at \code{x}
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' T <- matrix(c(c(-1,0,0),c(1,-2,0),c(0,1,-5)), nrow = 3, ncol = 3)
#' mu <- 1
#' sigma <- 2
#' xi <- 0.5
#' mGEVcdf(0.5, alpha, T, mu, sigma, xi) 
#' mGEVcdf(0.5, alpha, T, mu, sigma, xi, FALSE) 
mGEVDcdf <- function(x, pi, T, mu, sigma, xi, lower_tail = TRUE) {
    .Call(`_matrixdist_mGEVDcdf`, x, pi, T, mu, sigma, xi, lower_tail)
}

#' Bivariate phase-type joint density
#' 
#' @examples
#' alpha <- c(0.15, 0.85)
#' T11 <- matrix(c(c(-2,9),c(0,-11)), nrow = 2, ncol = 2)
#' T12 <- matrix(c(c(2,0),c(0,2)), nrow = 2, ncol = 2)
#' T22 <- matrix(c(c(-1,0),c(0.5,-5)), nrow = 2, ncol = 2)
#' x1 <- matrix(c(0.5,2), ncol=2) 
#' x2 <- matrix(c(c(0.5,1), c(2, 1.5)), ncol=2) 
#' bivphden(x1, alpha, T11, T12, T22) 
#' bivphden(x2, alpha, T11, T12, T22) 
bivphden <- function(x, alpha, T11, T12, T22) {
    .Call(`_matrixdist_bivphden`, x, alpha, T11, T12, T22)
}

#' Bivariate phase-type joint tail
#' 
#' @examples
#' alpha <- c(0.15, 0.85)
#' T11 <- matrix(c(c(-2,9),c(0,-11)), nrow = 2, ncol = 2)
#' T12 <- matrix(c(c(2,0),c(0,2)), nrow = 2, ncol = 2)
#' T22 <- matrix(c(c(-1,0),c(0.5,-5)), nrow = 2, ncol = 2)
#' x1 <- matrix(c(0.5,1), ncol=2) 
#' x2 <- matrix(c(c(0.5,1), c(2, 1.5)), ncol=2) 
#' bivphtail(x1, alpha, T11, T12, T22) 
#' bivphtail(x2, alpha, T11, T12, T22) 
bivphtail <- function(x, alpha, T11, T12, T22) {
    .Call(`_matrixdist_bivphtail`, x, alpha, T11, T12, T22)
}

#' Bivariate matrix Weibull joint density
#' 
#' @examples
#' alpha <- c(0.15, 0.85)
#' T11 <- matrix(c(c(-2,9),c(0,-11)), nrow = 2, ncol = 2)
#' T12 <- matrix(c(c(2,0),c(0,2)), nrow = 2, ncol = 2)
#' T22 <- matrix(c(c(-1,0),c(0.5,-5)), nrow = 2, ncol = 2)
#' beta <- c(0.5, 0.7)
#' x1 <- matrix(c(0.5,2), ncol=2) 
#' x2 <- matrix(c(c(0.5,1), c(2, 1.5)), ncol=2) 
#' bivmWeibden(x1, alpha, T11, T12, T22, beta) 
#' bivmWeibden(x2, alpha, T11, T12, T22, beta) 
bivmWeibden <- function(x, alpha, T11, T12, T22, beta) {
    .Call(`_matrixdist_bivmWeibden`, x, alpha, T11, T12, T22, beta)
}

#' Bivariate matrix Weibull joint tail
#' 
#' @examples
#' alpha <- c(0.15, 0.85)
#' T11 <- matrix(c(c(-2,9),c(0,-11)), nrow = 2, ncol = 2)
#' T12 <- matrix(c(c(2,0),c(0,2)), nrow = 2, ncol = 2)
#' T22 <- matrix(c(c(-1,0),c(0.5,-5)), nrow = 2, ncol = 2)
#' beta <- c(0.5, 0.7)
#' x1 <- matrix(c(0.5,1), ncol=2) 
#' x2 <- matrix(c(c(0.5,1), c(2, 1.5)), ncol=2) 
#' bimWeibtail(x1, alpha, T11, T12, T22, beta) 
#' bimWeibtail(x2, alpha, T11, T12, T22, beta) 
bimWeibtail <- function(x, alpha, T11, T12, T22, beta) {
    .Call(`_matrixdist_bimWeibtail`, x, alpha, T11, T12, T22, beta)
}

#' Bivariate matrix Pareto joint density
#' 
#' @examples
#' alpha <- c(0.15, 0.85)
#' T11 <- matrix(c(c(-2,9),c(0,-11)), nrow = 2, ncol = 2)
#' T12 <- matrix(c(c(2,0),c(0,2)), nrow = 2, ncol = 2)
#' T22 <- matrix(c(c(-1,0),c(0.5,-5)), nrow = 2, ncol = 2)
#' beta <- c(2, 4)
#' x1 <- matrix(c(0.5,2), ncol=2) 
#' x2 <- matrix(c(c(0.5,1), c(2, 1.5)), ncol=2) 
#' bivmParden(x1, alpha, T11, T12, T22, beta) 
#' bivmParden(x2, alpha, T11, T12, T22, beta) 
bivmParden <- function(x, alpha, T11, T12, T22, beta) {
    .Call(`_matrixdist_bivmParden`, x, alpha, T11, T12, T22, beta)
}

#' Bivariate matrix Weibull joint tail
#' 
#' @examples
#' alpha <- c(0.15, 0.85)
#' T11 <- matrix(c(c(-2,9),c(0,-11)), nrow = 2, ncol = 2)
#' T12 <- matrix(c(c(2,0),c(0,2)), nrow = 2, ncol = 2)
#' T22 <- matrix(c(c(-1,0),c(0.5,-5)), nrow = 2, ncol = 2)
#' beta <- c(2, 4)
#' x1 <- matrix(c(0.5,1), ncol=2) 
#' x2 <- matrix(c(c(0.5,1), c(2, 1.5)), ncol=2) 
#' bimPartail(x1, alpha, T11, T12, T22, beta) 
#' bimPartail(x2, alpha, T11, T12, T22, beta) 
bimPartail <- function(x, alpha, T11, T12, T22, beta) {
    .Call(`_matrixdist_bimPartail`, x, alpha, T11, T12, T22, beta)
}

#' Pi and T of a linear combination of a MPH*
#' 
#' @examples
#' pi <- c(0.15, 0.85, 0 ,0)
#' T11 <- matrix(c(c(-2,9),c(0,-11)), nrow = 2, ncol = 2)
#' T12 <- matrix(c(c(2,0),c(0,2)), nrow = 2, ncol = 2)
#' T22 <- matrix(c(c(-1,0),c(0.5,-5)), nrow = 2, ncol = 2)
#' T <- merge_matrices(T11, T12, T22)
#' R <- matrix(c(c(1,1,0,0), c(0,0,1,1)), ncol=2)
#' w1 <- c(1,0)
#' linear_combination(w1, pi, T, R)
#' w2 <- c(0,1)
#' linear_combination(w2, pi, T, R)
#' matrix(c(0.15, 0.85), ncol=2)%*%matrix_inverse(T11 * (-1))%*%T12
#' w3 <- c(1,1)
#' linear_combination(w3, pi, T, R)
linear_combination <- function(w, pi, T, R) {
    .Call(`_matrixdist_linear_combination`, w, pi, T, R)
}

#' Joint MGF of a MPH
jointMGF <- function(w, pi, T, R) {
    .Call(`_matrixdist_jointMGF`, w, pi, T, R)
}

#' Product of two matrices
#' 
#' Computes C = A * B
matrix_product <- function(a, b) {
    .Call(`_matrixdist_matrix_product`, a, b)
}

#' Add matrices
#' 
#' Computes C =  A + B 
#' @param A A matrix
#' @param B A matrix
matrix_sum <- function(A, B) {
    .Call(`_matrixdist_matrix_sum`, A, B)
}

#' L-oo norm of a matrix
#' 
#' Computes the L-oo norm of a matrix \code{A}, which is defined as:
#' L-oo A =  max ( 1 <= I <= M ) sum ( 1 <= J <= N ) abs ( A(I,J) ).
#' @param A A matrix
LInf_norm <- function(A) {
    .Call(`_matrixdist_LInf_norm`, A)
}

#' Solves a system with multiple right hand sides
#' 
#' AX=B which can be decompose as LUX=B and finds X
#' When B is the identity matrix the solution is the inverse of A
solve_linear_system <- function(A1, B) {
    .Call(`_matrixdist_solve_linear_system`, A1, B)
}

#' Inverse of a matrix
matrix_inverse <- function(A) {
    .Call(`_matrixdist_matrix_inverse`, A)
}

#' Matrix exponential algorithm
#' 
#' MATLAB's built-in algorithm - Pade approximation
matrix_exponential <- function(A) {
    .Call(`_matrixdist_matrix_exponential`, A)
}

#' Maximum entry in a matrix
matrixMax <- function(A) {
    .Call(`_matrixdist_matrixMax`, A)
}

#' Maximum entry in the diagonal of a matrix
matrixMaxDiagonal <- function(A) {
    .Call(`_matrixdist_matrixMaxDiagonal`, A)
}

#' Computes A^n
matrix_power <- function(n, A) {
    .Call(`_matrixdist_matrix_power`, n, A)
}

clone_vector <- function(v) {
    .Call(`_matrixdist_clone_vector`, v)
}

clone_matrix <- function(m) {
    .Call(`_matrixdist_clone_matrix`, m)
}

#' Creates the matrix  (A1, B1 ; 0, A2)
matrix_VanLoan <- function(A1, A2, B1) {
    .Call(`_matrixdist_matrix_VanLoan`, A1, A2, B1)
}

#' Creates a matrix with the given vector in the diagonal
diagonal_vector <- function(vec) {
    .Call(`_matrixdist_diagonal_vector`, vec)
}

rcpp_hello_world <- function() {
    .Call(`_matrixdist_rcpp_hello_world`)
}

#' Random structure of a phase-type
#' 
#' Generates random parameters \code{pi} and \code{T} of a phase-type distribution of dimension \code{p} with chosen structure
#' @param p Dimension of the phase-type
#' @param structure Type of structure: "General", "Hyperexponential", "GErlang", "Coxian" or "GCoxian"
#' @param scale_factor A factor that multiplies the sub-intensity matrix
#' @return Random parameters \code{pi} and \code{T} of a phase-type
#' @examples
#' random_structure(3) 
#' random_structure(5, "Hyperexponential") 
random_structure <- function(p, structure = "General", scale_factor = 1) {
    .Call(`_matrixdist_random_structure`, p, structure, scale_factor)
}

#' Random reward matrix
#' 
#' The rows of the matrix sum to 1
random_reward <- function(p, dim) {
    .Call(`_matrixdist_random_reward`, p, dim)
}

#' Changes the values of T and R to make the MPH* having rewards that sum to 1
#' 
#' Better clone T and R?
norm_mph <- function(T, R) {
    invisible(.Call(`_matrixdist_norm_mph`, T, R))
}

#' Merges the matrices T11, T12 and T22 of a bivariate matrix
#' 
merge_matrices <- function(T11, T12, T22) {
    .Call(`_matrixdist_merge_matrices`, T11, T12, T22)
}

#' Random parameters of a bivariate phase-type
random_phase_BivPH <- function(p1, p2, scale_factor = 1) {
    .Call(`_matrixdist_random_phase_BivPH`, p1, p2, scale_factor)
}

